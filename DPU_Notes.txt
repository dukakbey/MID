DPU
===========
ders 1:

DPU kaynak kod gitlab : http://192.168.21.86/
Diğer kaynak kodlar: http://192.168.21.102

throubleShouting:
    - xx.lib does not exist derse manuel olarak linker -> input ayarına ilgili lib dosyasını eklersin.

Sorular .
	- Underground ve Fence modu ? 
dll'ler:
	- cublass*.dll , cudnn*.dll ,cufftw*.dll,curand*.dll,cusolver*.dll dosyaları algoritma ile ilgili. Ekran kartı üzerinde machine learning işlerinin yapılmasını sağlıyor.Model input verip model output üretilmesini sağlayan kütüphanelerin dll'leri.
	- nvinfer*.dll, nvm.dll, nvonnxparser*.dll, nvparsers*.dll,nvrtc*.dll, onnx*.dll  dll dosyaları onnx uygulamasının çalışması için gereklidir.	
	- onnxruntime_providers_tensorrt.dll : hızlandırıcıdır. Modelin ekran kartında daha hızlı çalışabilmesi için gerekli. 
	- DPU çalışabilmesi için CUDA kurulu olmalıdır.
	- poco dll'leri 

ONNX:
	- makine öğrenimi ve derin öğrenme modellerinin farklı frameworkler arasında taşınmasını kolaylaştıran açık kaynaklı bir formattır. 
	- ONNX, özellikle farklı platformlar ve frameworkler arasında birlikte çalışabilirliği artırmayı amaçlar. 
	- Makine öğrenimi modelleri genellikle belirli frameworklerde (örneğin, TensorFlow, PyTorch, MXNet, Scikit-learn) eğitilir. Ancak bu frameworkler arasında doğrudan bir geçiş yapmak zor olabilir. ONNX'in amacı, bu modellerin farklı frameworkler arasında kolayca taşınabilmesi ve her bir platformun avantajlarından yararlanabilmesi için ortak bir format sağlamaktır. 
	- ONNX, bir modelin eğitimden üretime geçirilmesini hızlandırır ve model taşınabilirliğini artırır.
	- datapostgresql.dll postgre ile konuşmamızı sağlıyor.
	- pocoJSON*.dll config dosyalarının json formatında kaydedilmesini sağlıyor. 
	- pocoNet64.dll web socket özelliklerini sağlıyor.
	- tensorflow.dll onnx altyapısı yokken kullanılıyordu, şuan kullanılmıyor.
	- vcruntime140_1.dll : visual stdio'nun ihtiyaç duyduğu bir dosya.
POCO:
	- POCO (POrtable COmponents), modern ağ ve internet tabanlı uygulamaları geliştirmek için kullanılan açık kaynaklı bir C++ sınıf kütüphanesidir. 
	- Genellikle C++ için Boost kütüphanesine benzeyen özellikler sunar, ancak daha fazla ağ, internet, veri tabanı, XML, JSON gibi uygulama geliştirme bileşenlerini de içerir.
	- Server tabanlı yazılımlar geliştirilmesini sağlıyor. DPU'da aktif kullanılıyor. 
	- PostgreSQL ile konuşuyor. Alarm analizi yapıyor ve activity count'ları veritabanına kaydediyor.
	- dll'lerin oluşturulması gerekiyor bu nedenle kütüphane derlenmesi gerekiyor ve dokümanlarında anlatılıyor.
	
.pdb (Program Database) Dosyası:
	- Program Database anlamına gelir ve derleme sırasında derleyici tarafından oluşturulan bir dosyadır. Bu dosya, uygulamanızın sembol bilgilerini (fonksiyon isimleri, değişkenler, veri yapıları gibi), kaynak kod satırı numaralarını ve hata ayıklama (debugging) bilgilerini içerir.
	
.bsc (Source Browser) Dosyası:
	- BSC dosyası, Source Browser dosyası anlamına gelir. Bu dosya, derlenen C++ projesindeki sembollerin ve kaynak kodun taranması ve incelenmesi için kullanılan bir dosyadır. 
	- BSC dosyaları, projedeki sembollerin referanslarının hızlı bir şekilde aranmasına yardımcı olur ve Visual Studio gibi IDE'lerde "Go To Definition" ya da "Find All References" gibi özellikleri kullanırken arka planda çalışır.		
	


dpu_config.h:
		- ProcessedDataRecorderParameters: waterfall burada tutuluyor.
BOOST:
	- boost::asio:io_service socket oluşturma ve multithreading işlemler için kullanılır.
	- 

Derleme:
	- release_Od olarak derleniyor.
	
Kütüphaneleri Ekleme:
	- visual studio Additional Include Directories  


ders 2 (kütüphaneler devam): 
dpu_main.cpp:
	- _setmaxstdio(2048) : 2 gb anlık olarak dosya açabiliyoruz. DPU özelinde 2gb üstüne çıkmaya çalıştığında işletim sistemi sınır getiriyor, açamıyoruz. Mesela Alarm triger kayıtlarında aynı anda 500 alar oldu. Waterfall ses kayıtlarında raw data oluşturuluyor. Aynı anda yapılmaya çalışıldığında işletim sistemi sınır koyuyor. Alarmlar oluşmayabilir default 1 GB'di bu ayar ile 2gb'ye çıkarıldı.
	- DPU_VERSION : commit'e göre elle git üzerinden güncellenmesi gerekiyor.
    - DPU yazılımı 2 adet sinyal kullanıyor:
        - TerminationSignalHandler: ctrl + c handle edilir.
    - yazılımın çalışması için 3 temel şeye ihtiyaç var: 
        - ilk önce config dosyalarını okuyor. Bunu yapan dpu_config_factory :
            default_config_folder_ = ".\\run_time_files\\config\\default"; :yazılımı ayağa kaldırmak için minimum ihtiyaç duyduğu parametreler.
            application_config_folder_="C:\\MIDAS\\config\\application";: sahaya göre değişen parametreler.
            user_config_folder_="C:\\MIDAS\\config\\user"; : kullanıcının sahada değiştirmiş olduğu ayarlar. örneğin: sensörlerin ip'leri, seri portları farklı olabilir. saha aynı olsa da bu ayarlar bu katmanda değiştirilir.
            web_server_root_folder_ = ".\\run_time_files\\html"; : 9980,9981 (son kullanıcı için  detay içermeyen 2. arayüz) sorgulayıcı cihazların ve DPU yazılımının ayarlarını yapabildiğimiz, algoritma parametrelerini,raw dataların takibini yapabildiğimiz değiştirebildiğimiz bir DPU arayüz var. Bu arayüz'ün HTML dosyalrının bulunduğu path.
        - 
    dpu_config_factory: 
        - gelen json mesajlarını ayrıştırıyor:
            - on_demand geldiğinde ona göre işlem yapıyor.
            - update 'e tıklandığında bu işlemin update mi save mi olduğunu belirler.
	dpu_config :
		- config dosyalarındaki
		- dpu_config_factory'de constructor parametlerei olan 3 config dosyasının içeriğindeki parametreler dpu_config.h 'de tutulan değişkenlere map'leniyor. 
	- global sabitler global_constant namespace'inde tutuluyor.

Visual Studio Properties settings:
    Build Event: 
        - Visual studio properties altında yer alan Build event kısmında Command Line adında bir ayarımız var. Burada her build işlemi gerçekleştiğinde çalışacak komut giriyoruz. Bu komut bize "version.h" oluşturuyor.
        -
    Code Generation:
        - Enable Enhanced Instruction Set: Advanced Vector Extensions (X86/X64) (/arch:AVX) olmalı. Bu seçenek seçilmezse uygulama yavaş çalışabilir. 
        - Bu mimaride CPU'da bazı işlemler oluyor ve CPU üzerinde işlemleri hızlandırıyor.
        - Bu sekmede Runtime Library ayarı multithread dll (md) olmalıdır.  

model_info.json:
	- tensorrt_workspace_size: 104857600 : 10gb gpu'da ayrılacak bellek sınırı. Bu ana modelimizin (midas_model_best_freeze2D.onnx) config dosyasıdır.
	- tensorrt_cache_path:  
		- D://tensorrt_cache_activity_classifier_underground_model*** . Model için gpu'da yapılacak cache'leme için path. 
		- her açılışta modelin gpu'ya taşınmasını engelliyor. Zamanında her açılışta modelin aktarılması 1 dk sürüyordu.
	- feature_extractor: her kanal için 32*48'lik window'lar çıkarıyor. 

**Sistemde olmayan bir parametre eklendiğinde:
	- öncelikle config.h'a ekle.
	- sonrasında config_parser'da 

DPUConfigFactory:
	- CreateDefaultZoneParameters: fence ya da underground çalışılacak bölgelerin belirlenmesini sağlıyor.


===================================
ders 3 (dpu_config):
dpu_config:
	- RecorderMainParameters: rolling_raw ve on_demand için 
	
	- preproccessorParameters:
		- number_of_samples_in_one_windows: 400 => 2 boyutlu matris. Algoritmaya 5150*400'lük veri geliyor.
		- number_of_openmp_threads: işi rahatlatmak için thread kullanımı artırılabilir ama bellek kullanımı artar. 
	
	- FileDataSourceParameters: 
		- file_datasource_enable : 1 olursa dosyadan okur.
		- file_data_source_loop: 1 olursa aynı data bittiği zaman tekrar tekrar oynatır.
	- ClassificationParameters: 
		-selected_mod: underground veya fence olabilir.

	- Logger_Parameters:
		- rotation_size: 10485760 (10 GB'ye ulaştığı zaman eski kayıtlı dosyaları sil) 
		- max_size: 
	- PerformanceSettingsParameters:
		- son kullanıcının çok kullandığı parametreleri tutuyor.
		- max_number_of_channels_to_display_on_gui: takip etmek istediğimiz kanal sayısı:
			- Midas2 : 5150
			- Midas3 : [1000,1000] => [1.fiber,2.fiber]
		- zone_parameter:
			- underground:
				-range : hangi kanallar arası underground olacağını seçiyoruz.
			- fence:
				-range : hangi kanallar arası fence olacağını seçiyoruz.
===================================
ders 4 (dpu_config):
dpu_config:
	- fiber_length_in_number_of_channels: (linecut algoritmasının parametresi)
		- Midas2 : 3000
		- Midas3 : [1000,1000] => [1.fiber,2.fiber]
	- zone_parameter: bir yazılım hem fence hem de underground modunda çalışabilir. Zone'lar bunu sağlıyor.
			- underground:
				-range : hangi kanallar arası underground olacağını seçiyoruz.
			- fence:
				-range : hangi kanallar arası fence olacağını seçiyoruz.
			- vector<map<int,int>> map_channels_to_activity_types: her kanal'da aşağıdaki activity'lerin karşılıklarını tutuyor:
					activity_name 		report_activity_flag
				-  	human(1)				0
				- 	vehicle(2) 				0		
				- 	digging	(0)				1
				- 	excavator(3)			2
				- probability accumulator'den dolayı activity_name string değil.
	- DPUConfigFilesDefaultParameters:
		-ExternalInterfaceParameters :  boost tcp modülü ile soket açılıyor ve bu soket üzerinden dpu yazılımının oluşturduğu waterfall ,alarm ,ses verileri, cit mesajları TCP üzerinden MSM yazılımına gönderiliyor.
			- gui_interface_tcp_server_port: 19193
			- enable_cit_messages : 1
			- Örnek Cit mesajları:
				- FPGA ısındı
				- ethernet üzerinden raw data alınamadığı zaman raw_data_not_received mesajı 
		- AlarmAnalyzerParameters: 
			- alarm 'ın derecelendirmesine göre renklendirme yapıyor.
			- alarm kanalının 14 günlük activity count'larını tutar.
		- StatisticRecorderParameters
==========================================
ders 5 (kütüphaneler devam):

===============================================
ders 6 :


bool ParseConfigFile: dosyadan configleri alma işlemini tetikliyor.
void SaveJSONToFile: kullanıcının girdiği ile default arasındaki farkı buluyor.
string JsonToConfig: 
ConfigToJason: web arayüzüne gönderirken.

!!!! dpu_*.cfg dosyalarından configleri okurken dosyada parametrelerde yer alan hataları handle eden try catch bloğu yok. Yazılım patlıyor.

communication_path: sorgulayıcı cihazın komut alma ve gönderme path'ini değiştirmek için kullanılan fonksiyonlar.
	- 0: serial port
	- 1: ethernet

interrogator_usage_types:
	- 0 : single
	- 1 : redundant
	- 2 : seperate

interrogator_device_type:
	- 0: midas v1.5
	- 1: midas v2
	- 2: midas v3a
	- 3: midas v3
	- 4: midas v4

fiber_number:
	- 1 : sadece fiber-1'den data gelir.
	- 2 : sadece fiber-2'den data gelir.
	- 3 : fiber-1 ve fiber-2'den data gelir.

underground activity_types:	
	- human
	- vehicle
	- digging
	- excavator
	
fence activity_types:
	- climb 
	- cut

WebSocketRequestResponder: DPUServer içerisinde bir sınıf. DPU localhost:99 web arayüzü üzerinden gelen istekler DPUServer'a geliyor.	
DPUServer: 
	- Hem web arayüzünü ayağa kaldıran hem de web arayüzünden gelen istekleri dinleyen dinleyici bir sınıf. 

!! sahada şöyle bir durum var fragmentasyonun yoğun olduğu bazı sensörlerde (diski gitmiş olan,hdd kullanan) ne kadar yazılımda recor'derda (raw data, alarm ticker,ses verisi) multithreading kullansak da bazen waterfall takılabiliyor. çözüm:
	- dpu_default_recorder.cfg'de target_folder'a D'den C'ye taşı.
================================
ders 7 : DPU'dan raw data nasıl geliyor kısmına odaklanıldı.:
interrogator_device_packet_structere.docx: 
- DPU'nun raw data'yı düzgün bir şekilde parse etmesini sağlayacak adımlar.
- Midas 2 cihazı 5150 kanal ve 1942 hz olarak çalıştığı senaryoda gönderdiği paket yapısı anlatılmaktadır.
- cihaz fragment'ler halinde data yolluyor:
	- her fragment içinde packet_header ve payload kısmı mevcuttur.  
	- 8 adet fragment 1 frame'e karşılık gelir. ve 8 adet fragment tamamlandığı zaman 5150'lik bir kanaldan veri gelmiş oluyor.
	- 5150 kanalın (her kanal 2byte) her bir verisinin 8 adet küçük çank'lar halinde geldiğini düşünebiliriz. Biz bunları birleştiriyoruz.
	- her çank'ta header ve payload var
	- struct UDPPacketHeader //veri toplam 14 byte'lık : uint16_t short integer 2 byte / uint32_t : 4 byte
	{
		uint16_t message_ID; // normalde unique artan bir değer ama alınan verilerde öyle görünmüyor.
		uint32_t frame_count;// 8 fragment'te 1 artıyor.  
		uint16_t total_fragment_count;// toplam fragment sayısı midas için 8
		uint16_t frame_fragment_no;// düzenli olarak artıyor. 1'den 8'e kadar artan değerlere sahip oluyor.
		uint16_t info;//midas 2 için anlamlı değil sabit değer alıyor. midas 3 için önemli bir parametre: data'nın hangi fiber'den geldiğini gösteriyor. 0 ise 1.fiber, 1 ise 2.fiber.
		uint16_t message_length;//raw data'nın paket boyutunu gösteriyor. header(14byte) + payload size
	}PACKED;
	- 8 fragemnt'te gelen raw data 5150 kanal'a karşılık gelmiyorsa o raw data'yı algoritmaya vermiyor.
	- frame'ler mesaj kuyruğuna veriliyor. Bu mesaj kuyruğu 400 frame'e (windows size) ulaştığında algoritmaya veriliyor.

Yukarıda anlatılan mekanizmayı uygulayan sınıf DPU Pipeline:
	- Önce raw data dosya'dan mı okunacak kontrolü yapılıyor. File_data_source_enable: 1 ise dosyadan okunur.
	- File_data_source_enable : 0 ise UDPDataSource'a gider.
	- UDPDataSource işlemini bitirdikten sonra aşağıdaki sınıflar yaratılmalı (hepsi thread olarak çalışıyor):
		- raw_data_mediator: raw data'nın kaydedileceği yer olan recorder.
		- preprocessor : algoritmanın çalışacağı yer.
		- alarm buffer: alarm analizleri yapılacak kısım. 
		- tcp_data_sink: TCP üzerinden waterfall datasının ve alarmların gönderilmesi için egerekli olan soket bağlantısının oluşturulmasını sağlayan sınıf.
Pipeline:
	bu paketler farklı thread'ler halinde birbirleriyle sürekli messageQ üzerinden haberleşiyor. Kuyruğa raw data'nın pointer'ları yazılıyor.İlk 3'ü ortak bir messageQ kullanılıyor. Bu 3 mesajın ortak kullanıdığı message Q preproccessor üzerinde yer alıyor: AllocateBuffers(). Kuyrukta 20*400*5150 2byte'lık veri saklanıyor.
	1) data_source: 
		- udp_data_source:  sorgulayıcı cihazdan 4660 portundan gelen verinin alınmasını sağlıyor.
		- file_data_source: sorgulayıcı varmış gibi dosyadan okuma yaparak işlem yapmamızı sağlar.
	2) raw_data_mediator: 
		- Amacı raw data kaydı yapmak.  
		- alınan raw data buraya gönderilir. 2GB'lik dosyalar halinde kayıt yapılır.
		- raw data kaydı D:\MIDAS_RECORDS diskine yapılır.
		- 2 günlük kayıt yapar. 2 günlük kaydın boyutu 3TB. 3TB'a ulaştığı zaman eski kayıtları sistematik olarak siler.
		- RollingRaw : sürekli kayıt.
		- OnDemandRecorder: İçinde OnDemandRecorder mekanizması da var. localhost 9980 üzerinden isteğe bağlı kayıt alınması sağlanıyor.
	   recorder:
		- raw data'yı kaydeden sınıftır.
		- alarm bazlı kayıt, waterfall, ses verisi.. bunların hepsi recorder sınıfından türüyor.
		- info_recorder sınıfında multi_inheritance var. Bunun nedeni bazı on_demand ve rolling_data sınıflarındaki info kayıtlarını oluşturmak için oluşturulan bir class. 
	   rolling_raw_data_recorder:
		- boost_singleProducer, boost_singleConsumer mesaj kuyruğu sınıfları kullanılıyor. raw_data_mediator bu kuyruğa yazıyor.
	3) preprocessor: kaydedilen data preproccessor'a yollanıyor. Bu sayede algoritma alarmlar, waterfall.. üretiyor.
	4) alarm_buffer
	5) tcp_data_sink: tcp üzerinden datayı gönderiyor.

UDPDataSource:
	- burdan raw data 400*5150 2byte olarak iletiliyor.
========================================
ders 8: DPU'dan raw data nasıl geliyor kısmına odaklanıldı.:

udp_data_source.cpp:
	- 400 * 5150 'lik bufferlar ile data yollanıyor.
	- ConcealLostSamples() : tam ne işe yaradığı bilinmiyor. Kullanılmadığında/yorum satırına alındığında uygulama garip bir tepki veriyor.

raw_data_mediator:
 - Aracı bir sınıf asıl işi yapacak sınıflara raw_data yolluyor(rolling_raw_data_recorder,ondemand_raw_data_recorder). 
 -    
=============================================== 
ders 9: rolling_raw_data kısmına odaklanıldı.:

==========================================
ders 10: onDemand_raw_data kısmına odaklanıldı.:
* udp_data_source'dan gelen data raw_data_mediator'a geliyor. Mediator de aldığı raw data'ları rolling_raw_data'ya ve onDemand_raw_data'ya yolluyor.
* element_main_loop  data'nın yazılğı fonksiyon.
!! fragmentasyon problemini çözen işlemi on_demand'a da eklenmesi öneriliyor.
! writing_packet_byte_size_: Diske veriyi büyük boyutta yazmayı sağlıyor. çok düşük boyutta çank'lar halinde veri yazıldığı zaman diskin bozulma olasılığı artıyor.
! max_number_of_gui  ?
- windows_size_in_bytes: max_number_of_gui *400* 2 byte  bir iterasyonda kaydedilecek veri boyutu.

===============================================
ders 11: onDemand_raw_data,file_datasource_enable kısmına odaklanıldı.:
* Midas 2 cihazı hep 5150 kanal olarak ayarlanıyor. sahada 3000 kanal olsa bile 5150 olarak ayarlanır. frekans değeri değişmemesi için.

writeDataToFile:
	- buffer_read_ptr: 5*5150'nin pointer'ı
	- number_of_channels_offset: 
	- max_number_of_channels_to_display_on_gui : 400*5150'lik verinin her kanaldan 400*max_number_of_channels_to_display_on_gui'yi almasını sağlıyor.
	- record_byte_ptr
CurrentRollingRecordFileOperations():
	- dosya kapatma işlemi burda oluyor.
	- stop'a basıldığında veya autoStop açıksa timer ile yazılım durduruluyor.
	- 
WriteRecordDescriptionFile():
	- cihaz tipi ne, cihazın modu ne, record_date, cihaz kullanım tipi gibi bilgileri dosyaya yazıyor.

pipeline devam- data source: 
	-*** run_time_files=>config=>default=>dpu_default_development.cfg içinde file_datasource_enable'ı 1 yaparsak artık file'dan okur.

processor: 
	- udp_data_source -> raw_data_mediator -> preproccessor şeklinde akış ile buraya raw data geliyor.  processor'un amacı bu verilerin işlenmesi.
	- ham veri waterfall, ses, spektram , alarm'a dönüştürülüyor. Preprocessor içinde tetikleniyor.
	- number_of_channels_offset: seperate modda anlamsız ,düz sinyali bittiği yer bilgisi offset'liyor.
offset = max_number_of_channels - max_number_of_gui

dpu_default_communication.cfg :
	- "fibers" altında "channel_number" hiç değişmiyor. Değişirse frekans değişir. dpu_default_performance_settings.cfg ile oynanır. "PerformanceSettingsParameters" altında midas*_usage değiştirilir.

multi_input_zone_ofset: çok kullanılan birşey değil.
============================
ders 12 (preproccessor):

dpu_default_communication.cfg:
	- "fibers" altında "channel_number" hiç değişmiyor. Nanotam altyüklenici firma değiştirilmesini önermiyor. Performans sıkıntıları oluşabiliyor.

mod'lar:
	- single: tek kablo 
		- 5150 kanal
	- seperate: çift kablo
		- her kablo 1000 kanal 
	- redundant: 
	 	- 2 kablo 1000 kanal çember yapıda.

preprocessor.cpp:
	- Data önce raw_data_mediator'a gelir sonrasında preprocessor'a gelir. Process initialize edilerek sürekli raw_data_mediator üzerinden sürekli raw data gelecek şekilde başlatılıyor.
	- number_of_openmp_threads_: sayısı 4. Artırılırsa yazılımın daha hızlı bir şekilde çalışması sağlanır ama cpu kullanımı artar. 
	- 

int16_t :short integer

line_cut_detection,line_cut algotiması:
	- Hat kesilmesini kontrol ediyor.
	- kesilirse kesildiği yerden  fiber'in sonlandığı yere kadar olan kısmı diğer fiber'den alıyoruz.
	- redundant ve single'da tek bir line_cut algoritması çalışıyor.
	- seperate mod'da 2 line_cut algoritması çalışıyor. Fiber 1 ve Fiber 2 hat kesilmesini kontrol ediyor.

===================================================
ders 13(preproccessor):
weak_signal_detector:
	- Bir süre önceki sinyal ile karşılaştırarak sinyalda azalma veya kopma olduğunu saptayan bir algoritma. 

preproccessor'e raw datanın geldiği değişken :
	- int16_t* in_buf = (int16_t*)full_buffer_chunk_.buffer_pointer;
	- 
 
absolute_channels ?:
	- 0-2000 veya 0-5150 arası bir değerdir.
	
activity_count:
	- ?? 
===========================
ders 14 (preproccessor):
alarm bazlı kayıt:
	- ALARM_TRIGGERED_RAW_DATA_RECORDER
	- ALARM_TRIGGERED_AUDIO_RECORDER
	- ALARM_TRIGGERED_WATERFALL_RECORDER

rolling_waterfall_recorder.cpp:
	- WriteDataToFile: max_number_of_gui kadar veriyi (5150 kanal) direk yazıyor. Windows mantığı olmadığı için daha kolay bir yazma işlemi.

tcp_messages.h:
	- WaterfallMessageHeader
===============================
ders 15 (preproccessor):
	- 

============================
ders 17 (alarm_analyzer):
	- 


============================
ders 18 (alarm_analyzer):

============================
ders 19 (alarm_analyzer, iu_communicator-MIDAS3_Komut_Mesaj_Parametre_2021 dokümanındaki komutlar anlatıldı):
MIDAS3_Komut_Mesaj_Parametre_2021.10.01.xlsx dokümanı ? 



============================
ders 20 (dpu ile ilgili anlatım tamamlandı.,iu_communicator):
C:/MIDAS/tools/nanotam_arayüz: burda Nanotam'ın kendi cihazları için ürettiği arayüzler yer alıyor.


SVGL17 Yazılım Tasarım Tanımları Dokümanı_RevB_V2  ?? 

============================
ders 21 (iu_communicator):
	- 


============================
ders 22 (iu_communicator):
	- 




============================
ders 23 (iu_communicator,dpu_server.cpp):
	- 



============================
ders 24 (request_responder,dpu_server, web_socket_request_responder.cpp):
	- 


============================
ders 26 (.js kodlar):
	- run_time_files -> html->9980 .js kodlar


============================
ders 27 (.js kodlar,arif yazılımı entegrasyonu,tcp_data_sink.cpp):
	- run_time_files -> html->9980 .js kodlar


