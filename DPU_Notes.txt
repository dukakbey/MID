DPU
===========
DPU kaynak kod gitlab : http://192.168.21.86/
Diğer kaynak kodlar: http://192.168.21.102

throubleShouting:
    - xx.lib does not exist derse manuel olarak linker -> input ayarına ilgili lib dosyasını eklersin.

Sorular .
	- Underground ve Fence modu ? 
dll'ler:
	- cublass*.dll , cudnn*.dll ,cufftw*.dll,curand*.dll,cusolver*.dll dosyaları algoritma ile ilgili. Ekran kartı üzerinde machine learning işlerinin yapılmasını sağlıyor.Model input verip model output üretilmesini sağlayan kütüphanelerin dll'leri.
	- nvinfer*.dll, nvm.dll, nvonnxparser*.dll, nvparsers*.dll,nvrtc*.dll, onnx*.dll  dll dosyaları onnx uygulamasının çalışması için gereklidir.	
	- onnxruntime_providers_tensorrt.dll : hızlandırıcıdır. Modelin ekran kartında daha hızlı çalışabilmesi için gerekli. 
	- DPU çalışabilmesi için CUDA kurulu olmalıdır.
	- poco dll'leri 

ONNX:
	- makine öğrenimi ve derin öğrenme modellerinin farklı frameworkler arasında taşınmasını kolaylaştıran açık kaynaklı bir formattır. 
	- ONNX, özellikle farklı platformlar ve frameworkler arasında birlikte çalışabilirliği artırmayı amaçlar. 
	- Makine öğrenimi modelleri genellikle belirli frameworklerde (örneğin, TensorFlow, PyTorch, MXNet, Scikit-learn) eğitilir. Ancak bu frameworkler arasında doğrudan bir geçiş yapmak zor olabilir. ONNX'in amacı, bu modellerin farklı frameworkler arasında kolayca taşınabilmesi ve her bir platformun avantajlarından yararlanabilmesi için ortak bir format sağlamaktır. 
	- ONNX, bir modelin eğitimden üretime geçirilmesini hızlandırır ve model taşınabilirliğini artırır.
	- datapostgresql.dll postgre ile konuşmamızı sağlıyor.
	- pocoJSON*.dll config dosyalarının json formatında kaydedilmesini sağlıyor. 
	- pocoNet64.dll web socket özelliklerini sağlıyor.
	- tensorflow.dll onnx altyapısı yokken kullanılıyordu, şuan kullanılmıyor.
	- vcruntime140_1.dll : visual stdio'nun ihtiyaç duyduğu bir dosya.
POCO:
	- POCO (POrtable COmponents), modern ağ ve internet tabanlı uygulamaları geliştirmek için kullanılan açık kaynaklı bir C++ sınıf kütüphanesidir. 
	- Genellikle C++ için Boost kütüphanesine benzeyen özellikler sunar, ancak daha fazla ağ, internet, veri tabanı, XML, JSON gibi uygulama geliştirme bileşenlerini de içerir.
	- Server tabanlı yazılımlar geliştirilmesini sağlıyor. DPU'da aktif kullanılıyor. 
	- PostgreSQL ile konuşuyor. Alarm analizi yapıyor ve activity count'ları veritabanına kaydediyor.
	- dll'lerin oluşturulması gerekiyor bu nedenle kütüphane derlenmesi gerekiyor ve dokümanlarında anlatılıyor.
	
.pdb (Program Database) Dosyası:
	- Program Database anlamına gelir ve derleme sırasında derleyici tarafından oluşturulan bir dosyadır. Bu dosya, uygulamanızın sembol bilgilerini (fonksiyon isimleri, değişkenler, veri yapıları gibi), kaynak kod satırı numaralarını ve hata ayıklama (debugging) bilgilerini içerir.
	
.bsc (Source Browser) Dosyası:
	- BSC dosyası, Source Browser dosyası anlamına gelir. Bu dosya, derlenen C++ projesindeki sembollerin ve kaynak kodun taranması ve incelenmesi için kullanılan bir dosyadır. 
	- BSC dosyaları, projedeki sembollerin referanslarının hızlı bir şekilde aranmasına yardımcı olur ve Visual Studio gibi IDE'lerde "Go To Definition" ya da "Find All References" gibi özellikleri kullanırken arka planda çalışır.		
	
dpu_main.cpp:
	- _setmaxstdio(2048) : 2 gb anlık olarak dosya açabiliyoruz. DPU özelinde 2gb üstüne çıkmaya çalıştığında işletim sistemi sınır getiriyor, açamıyoruz. Mesela Alarm triger kayıtlarında aynı anda 500 alar oldu. Waterfall ses kayıtlarında raw data oluşturuluyor. Aynı anda yapılmaya çalışıldığında işletim sistemi sınır koyuyor. Alarmlar oluşmayabilir default 1 GB'di bu ayar ile 2gb'ye çıkarıldı.
	- DPU_VERSION : commit'e göre elle git üzerinden güncellenmesi gerekiyor.
    - DPU yazılımı 2 adet sinyal kullanıyor:
        - TerminationSignalHandler: ctrl + c handle edilir.
    - yazılımın çalışması için 3 temel şeye ihtiyaç var: 
        - ilk önce config dosyalarını okuyor. Bunu yapan dpu_config_factory :
            default_config_folder_ = ".\\run_time_files\\config\\default"; :yazılımı ayağa kaldırmak için minimum ihtiyaç duyduğu parametreler.
            application_config_folder_="C:\\MIDAS\\config\\application";: sahaya göre değişen parametreler.
            user_config_folder_="C:\\MIDAS\\config\\user"; : kullanıcının sahada değiştirmiş olduğu ayarlar. örneğin: sensörlerin ip'leri, seri portları farklı olabilir. saha aynı olsa da bu ayarlar bu katmanda değiştirilir.
            web_server_root_folder_ = ".\\run_time_files\\html"; : 9980,9981 (son kullanıcı için  detay içermeyen 2. arayüz) sorgulayıcı cihazların ve DPU yazılımının ayarlarını yapabildiğimiz, algoritma parametrelerini,raw dataların takibini yapabildiğimiz değiştirebildiğimiz bir DPU arayüz var. Bu arayüz'ün HTML dosyalrının bulunduğu path.
        - 
    dpu_config_factory: 
        - gelen json mesajlarını ayrıştırıyor:
            - on_demand geldiğinde ona göre işlem yapıyor.
            - update 'e tıklandığında bu işlemin update mi save mi olduğunu belirler.
	dpu_config :
		- config dosyalarındaki
		- dpu_config_factory'de constructor parametlerei olan 3 config dosyasının içeriğindeki parametreler dpu_config.h 'de tutulan değişkenlere map'leniyor. 
	- global sabitler global_constant namespace'inde tutuluyor.

dpu_config.h:
		- ProcessedDataRecorderParameters: waterfall burada tutuluyor.
BOOST:
	- boost::asio:io_service socket oluşturma ve multithreading işlemler için kullanılır.
	- 

Derleme:
	- release_Od olarak derleniyor.
	
Kütüphaneleri Ekleme:
	- visual studio Additional Include Directories  

Visual Studio Properties settings:
    Build Event: 
        - Visual studio properties altında yer alan Build event kısmında Command Line adında bir ayarımız var. Burada her build işlemi gerçekleştiğinde çalışacak komut giriyoruz. Bu komut bize "version.h" oluşturuyor.
        -
    Code Generation:
        - Enable Enhanced Instruction Set: Advanced Vector Extensions (X86/X64) (/arch:AVX) olmalı. Bu seçenek seçilmezse uygulama yavaş çalışabilir. 
        - Bu mimaride CPU'da bazı işlemler oluyor ve CPU üzerinde işlemleri hızlandırıyor.
        - Bu sekmede Runtime Library ayarı multithread dll (md) olmalıdır.  

model_info.json:
	- tensorrt_workspace_size: 104857600 : 10gb gpu'da ayrılacak bellek sınırı. Bu ana modelimizin (midas_model_best_freeze2D.onnx) config dosyasıdır.
	- tensorrt_cache_path:  
		- D://tensorrt_cache_activity_classifier_underground_model*** . Model için gpu'da yapılacak cache'leme için path. 
		- her açılışta modelin gpu'ya taşınmasını engelliyor. Zamanında her açılışta modelin aktarılması 1 dk sürüyordu.
	- feature_extractor: her kanal için 32*48'lik window'lar çıkarıyor. 

**Sistemde olmayan bir parametre eklendiğinde:
	- öncelikle config.h'a ekle.
	- sonrasında config_parser'da 

ders 6 :
bool ParseConfigFile: dosyadan configleri alma işlemini tetikliyor.
void SaveJSONToFile: kullanıcının girdiği ile default arasındaki farkı buluyor.
string JsonToConfig: 
ConfigToJason: web arayüzüne gönderirken.

!!!! dpu_*.cfg dosyalarından configleri okurken dosyada parametrelerde yer alan hataları handle eden try catch bloğu yok. Yazılım patlıyor.
 
interrogator_device_types:
	- single
	- redundant
	- seperate

fiber number : 
communication_path: sorgulayıcı cihazın komut alma ve gönderme path'ini değiştirmek için kullanılan fonksiyonlar.
	- 0: serial port
	- 1: ethernet
interrogator_usage_types:
	- 0 : single
	- 1 : redundant
	- 2 : seperate

fiber_number:
	- 1 : sadece fiber-1'den data gelir.
	- 2 : sadece fiber-2'den data gelir.
	- 3 : fiber-1 ve fiber-2'den data gelir.

WebSocketRequestResponder: DPUServer içerisinde bir sınıf. DPU localhost:99 web arayüzü üzerinden gelen istekler DPUServer'a geliyor.	
DPUServer: 
	- Hem web arayüzünü ayağa kaldıran hem de web arayüzünden gelen istekleri dinleyen dinleyici bir sınıf. 

!! sahada şöyle bir durum var fragmentasyonun yoğun olduğu bazı sensörlerde (diski gitmiş olan,hdd kullanan) ne kadar yazılımda recor'derda (raw data, alarm ticker,ses verisi) multithreading kullansak da bazen waterfall takılabiliyor. çözüm:
	- dpu_default_recorder.cfg'de target_folder'a D'den C'ye taşı.

ders 7 : DPU'dan raw data nasıl geliyor kısmına odaklanıldı.:
interrogator_device_packet_structere.docx: 
- DPU'nun raw data'yı düzgün bir şekilde parse etmesini sağlayacak adımlar.
- Midas 2 cihazı 5150 kanal ve 1942 hz olarak çalıştığı senaryoda gönderdiği paket yapısı anlatılmaktadır.
- cihaz fragment'ler halinde data yolluyor:
	- her fragment içinde packet_header ve payload kısmı mevcuttur.  
	- 8 adet fragment 1 frame'e karşılık gelir. ve 8 adet fragment tamamlandığı zaman 5150'lik bir kanaldan veri gelmiş oluyor.
	- 5150 kanalın (her kanal 2byte) her bir verisinin 8 adet küçük çank'lar halinde geldiğini düşünebiliriz. Biz bunları birleştiriyoruz.
	- her çank'ta header ve payload var
	- struct UDPPacketHeader //veri toplam 14 byte'lık : uint16_t short integer 2 byte / uint32_t : 4 byte
	{
		uint16_t message_ID; // normalde unique artan bir değer ama alınan verilerde öyle görünmüyor.
		uint32_t frame_count;// 8 fragment'te 1 artıyor.  
		uint16_t total_fragment_count;// toplam fragment sayısı midas için 8
		uint16_t frame_fragment_no;// düzenli olarak artıyor. 1'den 8'e kadar artan değerlere sahip oluyor.
		uint16_t info;//midas 2 için anlamlı değil sabit değer alıyor. midas 3 için önemli bir parametre: data'nın hangi fiber'den geldiğini gösteriyor. 0 ise 1.fiber, 1 ise 2.fiber.
		uint16_t message_length;//raw data'nın paket boyutunu gösteriyor. header(14byte) + payload size
	}PACKED;
	- 8 fragemnt'te gelen raw data 5150 kanal'a karşılık gelmiyorsa o raw data'yı algoritmaya vermiyor.
	- frame'ler mesaj kuyruğuna veriliyor. Bu mesaj kuyruğu 400 frame'e (windows size) ulaştığında algoritmaya veriliyor.

Yukarıda anlatılan mekanizmayı uygulayan sınıf DPU Pipeline:
	- Önce raw data dosya'dan mı okunacak kontrolü yapılıyor. File_data_source_enable: 1 ise dosyadan okunur.
	- File_data_source_enable : 0 ise UDPDataSource'a gider.
	- UDPDataSource işlemini bitirdikten sonra aşağıdaki sınıflar yaratılmalı (hepsi thread olarak çalışıyor):
		- raw_data_mediator: raw data'nın kaydedileceği yer olan recorder.
		- preprocessor : algoritmanın çalışacağı yer.
		- alarm buffer: alarm analizleri yapılacak kısım. 
		- tcp_data_sink: TCP üzerinden waterfall datasının ve alarmların gönderilmesi için egerekli olan soket bağlantısının oluşturulmasını sağlayan sınıf.

UDPDataSource:
	- 

ders 8: